<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LD Debate Rankings</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        .stat-card {
            backdrop-filter: blur(20px);
            background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.02) 100%);
            border: 1px solid rgba(255,255,255,0.08);
        }
        .glass {
            backdrop-filter: blur(20px);
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
        }
        .dropdown-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.2s ease-out;
            opacity: 0;
        }
        .dropdown-content.open {
            max-height: 2000px;
            opacity: 1;
        }
        .rank-badge {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
        }
        .competitor-row {
            transition: all 0.2s ease;
        }
        .competitor-row:hover {
            background: rgba(255,255,255,0.03);
        }
        .chevron {
            transition: transform 0.2s ease;
        }
        .chevron.open {
            transform: rotate(180deg);
        }
        input[type="file"] {
            display: none;
        }
        .btn {
            transition: all 0.2s ease;
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
        }
        .btn:active:not(:disabled) {
            transform: translateY(0);
        }
        
        /* Debug Panel Styles */
        .debug-tab.active {
            color: rgba(255, 255, 255, 0.9);
            border-color: rgb(59, 130, 246);
        }
        .debug-tab-content {
            min-height: 200px;
        }
        #debugContent.open {
            height: 400px;
        }
        .merge-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s ease;
        }
        .merge-card:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
        }
        .merge-card.warning {
            border-color: rgba(251, 191, 36, 0.3);
            background: rgba(251, 191, 36, 0.05);
        }
        .merge-card.error {
            border-color: rgba(239, 68, 68, 0.3);
            background: rgba(239, 68, 68, 0.05);
        }
        .code-tag {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            margin: 2px;
        }
        .code-tag.new {
            background: rgba(34, 197, 94, 0.2);
            color: rgb(134, 239, 172);
        }
        .code-tag.existing {
            background: rgba(59, 130, 246, 0.2);
            color: rgb(147, 197, 253);
        }
        .timeline-entry {
            padding: 4px 8px;
            border-left: 2px solid rgba(255, 255, 255, 0.1);
            margin-left: 8px;
        }
        .timeline-entry.merge {
            border-color: rgba(59, 130, 246, 0.5);
        }
        .timeline-entry.new {
            border-color: rgba(34, 197, 94, 0.5);
        }
        .timeline-entry.unresolved {
            border-color: rgba(239, 68, 68, 0.5);
        }
        .timeline-entry.tournament {
            border-color: rgba(168, 85, 247, 0.5);
            background: rgba(168, 85, 247, 0.1);
            margin-left: 0;
            border-left-width: 4px;
            font-weight: 600;
        }
    </style>
</head>
<body class="min-h-screen bg-[#0a0a0f] text-white antialiased">
    <div class="fixed inset-0 bg-gradient-to-br from-blue-950/30 via-transparent to-purple-950/20 pointer-events-none"></div>
    
    <div class="relative max-w-5xl mx-auto px-6 py-12 pb-32">
        <!-- Header -->
        <header class="mb-12">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-semibold text-white tracking-tight">LD Debate Rankings</h1>
                    <p class="text-sm text-white/40 mt-1">TOC Circuit • 
                        <select id="seasonSelect" class="bg-transparent text-white/60 outline-none border-b border-white/20 hover:border-white/40 focus:border-white/60 transition-colors cursor-pointer">
                            <option value="2025-2026" class="bg-[#0a0a0f]">2025-2026</option>
                            <option value="2024-2025" class="bg-[#0a0a0f]">2024-2025</option>
                        </select>
                    </p>
                </div>
                <div class="flex items-center gap-3">
                    <div id="loadingIndicator" class="hidden flex items-center gap-2 text-white/60 text-sm">
                        <svg class="animate-spin w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"/><path d="M12 2a10 10 0 0 1 10 10" stroke-linecap="round"/></svg>
                        <span id="loadingText">Loading...</span>
                    </div>
                    <button id="exportBtn" disabled class="btn flex items-center gap-2 bg-white/5 hover:bg-white/10 disabled:opacity-30 disabled:cursor-not-allowed text-white/60 px-4 py-2 rounded-lg text-sm font-medium">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                        <span>Export</span>
                    </button>
                </div>
            </div>
        </header>

        <!-- Stats -->
        <div class="grid grid-cols-3 gap-4 mb-8">
            <div class="stat-card rounded-xl p-4">
                <div class="text-xs text-white/30 uppercase tracking-wider mb-1">Competitors</div>
                <div class="text-2xl font-semibold text-white" id="stat-competitors">0</div>
            </div>
            <div class="stat-card rounded-xl p-4">
                <div class="text-xs text-white/30 uppercase tracking-wider mb-1">Tournaments</div>
                <div class="text-2xl font-semibold text-white" id="stat-tournaments">0</div>
            </div>
            <div class="stat-card rounded-xl p-4">
                <div class="text-xs text-white/30 uppercase tracking-wider mb-1">Rounds</div>
                <div class="text-2xl font-semibold text-white" id="stat-rounds">0</div>
            </div>
        </div>

        <!-- Head to Head Button -->
        <div class="mb-6">
            <button id="h2hBtn" disabled class="btn flex items-center gap-2 bg-gradient-to-r from-purple-500/20 to-blue-500/20 hover:from-purple-500/30 hover:to-blue-500/30 disabled:opacity-30 disabled:cursor-not-allowed text-white/80 px-5 py-3 rounded-xl text-sm font-medium border border-white/10 hover:border-white/20 transition-all">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                <span>Head to Head Comparison</span>
            </button>
        </div>

        <!-- Head to Head Modal -->
        <div id="h2hModal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden items-center justify-center p-4">
            <div class="bg-[#12121a] border border-white/10 rounded-2xl w-full max-w-3xl max-h-[90vh] overflow-hidden shadow-2xl">
                <!-- Modal Header -->
                <div class="px-6 py-4 border-b border-white/10 flex items-center justify-between">
                    <h3 class="text-lg font-semibold text-white">Head to Head Comparison</h3>
                    <button id="h2hClose" class="text-white/40 hover:text-white/80 transition-colors">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    </button>
                </div>
                
                <!-- Modal Body -->
                <div class="p-6 overflow-y-auto max-h-[calc(90vh-80px)] custom-scrollbar">
                    <!-- Competitor Selection -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <!-- Aff Selection -->
                        <div>
                            <label class="block text-xs text-white/40 uppercase tracking-wider mb-2">Affirmative</label>
                            <div class="relative">
                                <input type="text" id="h2hAffSearch" placeholder="Search competitor..." 
                                    class="w-full bg-white/5 border border-white/10 rounded-lg px-4 py-3 text-white placeholder-white/30 outline-none focus:border-blue-500/50 transition-colors">
                                <div id="h2hAffDropdown" class="absolute top-full left-0 right-0 mt-1 bg-[#1a1a24] border border-white/10 rounded-lg max-h-48 overflow-y-auto custom-scrollbar hidden z-10">
                                </div>
                            </div>
                            <div id="h2hAffSelected" class="mt-2 hidden">
                                <div class="bg-blue-500/10 border border-blue-500/30 rounded-lg p-3">
                                    <div class="flex items-center justify-between">
                                        <div>
                                            <div class="font-medium text-white" id="h2hAffName"></div>
                                            <div class="text-xs text-white/40" id="h2hAffCode"></div>
                                        </div>
                                        <div class="text-right">
                                            <div class="text-lg font-bold text-blue-400" id="h2hAffRating"></div>
                                            <div class="text-xs text-white/40" id="h2hAffRecord"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Neg Selection -->
                        <div>
                            <label class="block text-xs text-white/40 uppercase tracking-wider mb-2">Negative</label>
                            <div class="relative">
                                <input type="text" id="h2hNegSearch" placeholder="Search competitor..." 
                                    class="w-full bg-white/5 border border-white/10 rounded-lg px-4 py-3 text-white placeholder-white/30 outline-none focus:border-red-500/50 transition-colors">
                                <div id="h2hNegDropdown" class="absolute top-full left-0 right-0 mt-1 bg-[#1a1a24] border border-white/10 rounded-lg max-h-48 overflow-y-auto custom-scrollbar hidden z-10">
                                </div>
                            </div>
                            <div id="h2hNegSelected" class="mt-2 hidden">
                                <div class="bg-red-500/10 border border-red-500/30 rounded-lg p-3">
                                    <div class="flex items-center justify-between">
                                        <div>
                                            <div class="font-medium text-white" id="h2hNegName"></div>
                                            <div class="text-xs text-white/40" id="h2hNegCode"></div>
                                        </div>
                                        <div class="text-right">
                                            <div class="text-lg font-bold text-red-400" id="h2hNegRating"></div>
                                            <div class="text-xs text-white/40" id="h2hNegRecord"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- VS Divider -->
                    <div class="flex items-center justify-center my-6">
                        <div class="flex-1 h-px bg-white/10"></div>
                        <div class="px-4 text-2xl font-bold text-white/20">VS</div>
                        <div class="flex-1 h-px bg-white/10"></div>
                    </div>
                    
                    <!-- Prediction Section -->
                    <div id="h2hPrediction" class="hidden mb-6">
                        <h4 class="text-xs text-white/40 uppercase tracking-wider mb-3">Predicted Outcome</h4>
                        <div class="bg-white/5 rounded-xl p-4">
                            <div class="flex items-center justify-between mb-4">
                                <div class="text-center flex-1">
                                    <div class="text-3xl font-bold text-blue-400" id="h2hAffWinProb">50%</div>
                                    <div class="text-xs text-white/40 mt-1">Aff Win Probability</div>
                                </div>
                                <div class="text-white/20 text-2xl font-light">|</div>
                                <div class="text-center flex-1">
                                    <div class="text-3xl font-bold text-red-400" id="h2hNegWinProb">50%</div>
                                    <div class="text-xs text-white/40 mt-1">Neg Win Probability</div>
                                </div>
                            </div>
                            <div class="h-3 rounded-full overflow-hidden flex">
                                <div id="h2hProbBarAff" class="bg-gradient-to-r from-blue-600 to-blue-400 transition-all duration-500" style="width: 50%"></div>
                                <div id="h2hProbBarNeg" class="bg-gradient-to-r from-red-400 to-red-600 transition-all duration-500" style="width: 50%"></div>
                            </div>
                            <div class="mt-3 text-center text-sm text-white/60" id="h2hPredictionText">
                                Select both competitors to see prediction
                            </div>
                        </div>
                    </div>
                    
                    <!-- Past Matchups Section -->
                    <div id="h2hHistory" class="hidden">
                        <h4 class="text-xs text-white/40 uppercase tracking-wider mb-3">Past Matchups</h4>
                        <div id="h2hHistoryContent" class="space-y-2">
                        </div>
                        <div id="h2hNoHistory" class="hidden text-center py-8 text-white/30">
                            <svg class="w-10 h-10 mx-auto mb-2 opacity-40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
                            <p class="text-sm">These competitors have never faced each other</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Rankings -->
        <div class="glass rounded-2xl overflow-hidden">
            <div class="px-6 py-4 border-b border-white/5 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
                <h2 class="text-sm font-medium text-white/60" id="rankingsTitle">Top 50 Rankings</h2>
                <div class="relative">
                    <input type="text" id="searchInput" placeholder="Search all competitors..." 
                        class="bg-white/5 border border-white/10 rounded-lg px-4 py-2 pl-10 text-sm text-white placeholder-white/30 w-full sm:w-64 outline-none focus:border-white/30 transition-colors">
                    <svg class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-white/30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
                    <button id="clearSearch" class="absolute right-3 top-1/2 -translate-y-1/2 text-white/30 hover:text-white/60 hidden">
                        <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    </button>
                </div>
            </div>
            
            <div id="emptyState" class="text-center py-16 text-white/30">
                <svg class="w-12 h-12 mx-auto mb-3 opacity-40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><circle cx="12" cy="8" r="7"/><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"/></svg>
                <p class="text-sm">Loading rankings data...</p>
            </div>

            <div id="rankingsContainer" class="hidden divide-y divide-white/5">
            </div>
        </div>
    </div>

    <!-- Debug Panel -->
    <div id="debugPanel" class="fixed bottom-0 left-0 right-0 z-40">
        <!-- Toggle Bar -->
        <div id="debugToggle" class="bg-[#1a1a24] border-t border-white/10 px-6 py-3 cursor-pointer hover:bg-white/5 transition-colors flex items-center justify-between">
            <div class="flex items-center gap-3">
                <svg class="w-5 h-5 text-yellow-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"/>
                    <path d="m9 12 2 2 4-4"/>
                </svg>
                <span class="text-sm font-medium text-white/80">Debug Panel</span>
                <div class="flex items-center gap-2">
                    <span id="debugMergeCount" class="bg-blue-500/20 text-blue-400 text-xs px-2 py-0.5 rounded-full">0 merges</span>
                    <span id="debugUnresolvedCount" class="bg-red-500/20 text-red-400 text-xs px-2 py-0.5 rounded-full hidden">0 unresolved</span>
                </div>
            </div>
            <svg id="debugChevron" class="w-5 h-5 text-white/40 transition-transform" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>
        </div>
        
        <!-- Debug Content -->
        <div id="debugContent" class="bg-[#0d0d14] border-t border-white/5 max-h-[60vh] overflow-hidden transition-all duration-300" style="height: 0;">
            <div class="h-full flex flex-col">
                <!-- Tabs -->
                <div class="flex border-b border-white/10 px-4">
                    <button class="debug-tab active px-4 py-3 text-sm font-medium text-white/60 border-b-2 border-transparent hover:text-white/80 transition-colors" data-tab="merges">
                        Merges
                    </button>
                    <button class="debug-tab px-4 py-3 text-sm font-medium text-white/60 border-b-2 border-transparent hover:text-white/80 transition-colors" data-tab="unresolved">
                        Unresolved
                    </button>
                    <button class="debug-tab px-4 py-3 text-sm font-medium text-white/60 border-b-2 border-transparent hover:text-white/80 transition-colors" data-tab="competitors">
                        All Competitors
                    </button>
                    <button class="debug-tab px-4 py-3 text-sm font-medium text-white/60 border-b-2 border-transparent hover:text-white/80 transition-colors" data-tab="timeline">
                        Resolution Log
                    </button>
                </div>
                
                <!-- Search Bar -->
                <div class="px-4 py-3 border-b border-white/5">
                    <div class="relative">
                        <input type="text" id="debugSearch" placeholder="Search names, codes, tournaments..." 
                            class="w-full bg-white/5 border border-white/10 rounded-lg px-4 py-2 pl-10 text-sm text-white placeholder-white/30 outline-none focus:border-white/30 transition-colors">
                        <svg class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-white/30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
                    </div>
                </div>
                
                <!-- Tab Content -->
                <div class="flex-1 overflow-y-auto custom-scrollbar p-4">
                    <!-- Merges Tab -->
                    <div id="debugTabMerges" class="debug-tab-content">
                        <div id="debugMergesList" class="space-y-2"></div>
                        <div id="debugMergesEmpty" class="hidden text-center py-8 text-white/30">
                            <p class="text-sm">No merges to display</p>
                        </div>
                    </div>
                    
                    <!-- Unresolved Tab -->
                    <div id="debugTabUnresolved" class="debug-tab-content hidden">
                        <div id="debugUnresolvedList" class="space-y-3"></div>
                        <div id="debugUnresolvedEmpty" class="hidden text-center py-8 text-white/30">
                            <svg class="w-10 h-10 mx-auto mb-2 text-green-500/50" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                            <p class="text-sm text-green-400/60">All codes resolved successfully!</p>
                        </div>
                    </div>
                    
                    <!-- All Competitors Tab -->
                    <div id="debugTabCompetitors" class="debug-tab-content hidden">
                        <div id="debugCompetitorsList" class="space-y-1"></div>
                    </div>
                    
                    <!-- Timeline Tab -->
                    <div id="debugTabTimeline" class="debug-tab-content hidden">
                        <div id="debugTimelineList" class="space-y-1 font-mono text-xs"></div>
                        <div id="debugTimelineEmpty" class="hidden text-center py-8 text-white/30">
                            <p class="text-sm">Resolution log will appear here during processing</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // STATE
        // ============================================
        const state = {
            competitors: {},
            tournaments: [],
            processing: false,
            settings: {
                regionalDiversityPenalty: true,
                walkoversEnabled: true
            },
            tournamentEntriesMap: {},
            matchupHistory: {},
            h2hSelection: { aff: null, neg: null },
            // Debug state
            debugLog: [],
            mergeEvents: [],
            unresolvedCodes: {},
            competitorCreations: {}
        };

        // ============================================
        // CONSTANTS
        // ============================================
        const BASE_RATING = 1500;
        const BASE_K = 32;
        const BID_MULTIPLIERS = { 'octas': 1.3, 'quarters': 1.2, 'semis': 1.1, 'finals': 1.0 };
        const ELIM_BONUSES = { 'quarters': 10, 'semis': 20, 'finals': 30, 'winner': 40 };

        const GITHUB_CONFIG = {
            owner: 'masonoakhill',
            repo: 'masonoakhill.github.io',
            branch: 'main'
        };

        const getDirectUrl = (path) => `/${path}`;
        const fileCache = new Map();

        // ============================================
        // DOM ELEMENTS
        // ============================================
        const el = {
            seasonSelect: document.getElementById('seasonSelect'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            competitorsStat: document.getElementById('stat-competitors'),
            tournamentsStat: document.getElementById('stat-tournaments'),
            roundsStat: document.getElementById('stat-rounds'),
            exportBtn: document.getElementById('exportBtn'),
            emptyState: document.getElementById('emptyState'),
            rankingsContainer: document.getElementById('rankingsContainer'),
            searchInput: document.getElementById('searchInput'),
            clearSearch: document.getElementById('clearSearch'),
            rankingsTitle: document.getElementById('rankingsTitle'),
            h2hBtn: document.getElementById('h2hBtn'),
            h2hModal: document.getElementById('h2hModal'),
            h2hClose: document.getElementById('h2hClose'),
            h2hAffSearch: document.getElementById('h2hAffSearch'),
            h2hAffDropdown: document.getElementById('h2hAffDropdown'),
            h2hAffSelected: document.getElementById('h2hAffSelected'),
            h2hAffName: document.getElementById('h2hAffName'),
            h2hAffCode: document.getElementById('h2hAffCode'),
            h2hAffRating: document.getElementById('h2hAffRating'),
            h2hAffRecord: document.getElementById('h2hAffRecord'),
            h2hNegSearch: document.getElementById('h2hNegSearch'),
            h2hNegDropdown: document.getElementById('h2hNegDropdown'),
            h2hNegSelected: document.getElementById('h2hNegSelected'),
            h2hNegName: document.getElementById('h2hNegName'),
            h2hNegCode: document.getElementById('h2hNegCode'),
            h2hNegRating: document.getElementById('h2hNegRating'),
            h2hNegRecord: document.getElementById('h2hNegRecord'),
            h2hPrediction: document.getElementById('h2hPrediction'),
            h2hAffWinProb: document.getElementById('h2hAffWinProb'),
            h2hNegWinProb: document.getElementById('h2hNegWinProb'),
            h2hProbBarAff: document.getElementById('h2hProbBarAff'),
            h2hProbBarNeg: document.getElementById('h2hProbBarNeg'),
            h2hPredictionText: document.getElementById('h2hPredictionText'),
            h2hHistory: document.getElementById('h2hHistory'),
            h2hHistoryContent: document.getElementById('h2hHistoryContent'),
            h2hNoHistory: document.getElementById('h2hNoHistory')
        };

        // ============================================
        // DEBUG LOGGING FUNCTIONS
        // ============================================
        const debugLog = (type, message, data = {}) => {
            const entry = {
                timestamp: Date.now(),
                type: type,
                message: message,
                data: data
            };
            state.debugLog.push(entry);
            
            const colors = {
                'new': 'color: #22c55e',
                'merge': 'color: #3b82f6', 
                'unresolved': 'color: #ef4444',
                'tournament': 'color: #a855f7; font-weight: bold',
                'info': 'color: #6b7280',
                'warning': 'color: #f59e0b'
            };
            console.log(`%c[${type.toUpperCase()}] ${message}`, colors[type] || '', data);
        };

        const recordMerge = (canonicalName, newCode, tournament, existingCodes) => {
            const mergeEvent = {
                id: state.mergeEvents.length,
                canonicalName: canonicalName,
                newCode: newCode,
                tournament: tournament,
                existingCodes: [...existingCodes],
                timestamp: Date.now()
            };
            state.mergeEvents.push(mergeEvent);
            debugLog('merge', `"${newCode}" → "${canonicalName}"`, { tournament, existingCodes: [...existingCodes] });
        };

        const recordNewCompetitor = (name, code, tournament) => {
            state.competitorCreations[name] = {
                firstCode: code,
                firstTournament: tournament,
                timestamp: Date.now()
            };
            debugLog('new', `Created "${name}" from "${code}"`, { tournament });
        };

        const recordUnresolved = (code, tournament) => {
            if (!state.unresolvedCodes[tournament]) {
                state.unresolvedCodes[tournament] = new Set();
            }
            state.unresolvedCodes[tournament].add(code);
            debugLog('unresolved', `"${code}" not found in entries`, { tournament });
        };

        // ============================================
        // HELPER FUNCTIONS
        // ============================================
        const expectedScore = (ratingA, ratingB) => 1 / (1 + Math.pow(10, (ratingB - ratingA) / 400));

        const getKFactor = (tournamentNum, isTop50) => {
            const baseK = isTop50 ? 28 : BASE_K;
            if (tournamentNum <= 3) return baseK * 1.25;
            if (tournamentNum >= 8) return baseK * 0.75;
            return baseK;
        };

        const getSpeakerModifier = (speaks, isWin) => {
            if (isWin) return speaks >= 29 ? 1.1 : 1.0;
            return speaks >= 28.5 ? 0.9 : 1.0;
        };

        const normalizeName = (name) => {
            if (!name) return '';
            return name.toLowerCase().replace(/[^a-z\s]/g, '').replace(/\s+/g, ' ').trim();
        };

        const normalizeCode = (code) => {
            if (!code) return '';
            return code.toLowerCase().replace(/\s+/g, ' ').trim();
        };

        const extractSchoolFromCode = (code) => {
            if (!code) return '';
            const parts = code.trim().split(/\s+/);
            return parts.length < 2 ? code : parts.slice(0, -1).join(' ');
        };

        const log = (msg) => console.log(msg);

        // ============================================
        // NAME RESOLUTION - STRICT EXACT MATCH ONLY
        // ============================================
        const resolveCodeForTournament = (code, tournamentName) => {
            if (!code || !tournamentName) return null;
            
            const tournamentEntries = state.tournamentEntriesMap[tournamentName];
            if (!tournamentEntries) {
                console.warn(`[Resolution] No entries loaded for tournament: ${tournamentName}`);
                return null;
            }
            
            const normalizedCode = normalizeCode(code);
            const entry = tournamentEntries[normalizedCode];
            
            if (entry) {
                return {
                    name: entry.name,
                    originalCode: entry.originalCode,
                    school: entry.school
                };
            }
            
            // NO FALLBACK - return null if not found exactly
            return null;
        };

        // Create a new competitor object
        const createNewCompetitor = (id, school, fullName) => {
            return {
                id: id,
                school: school || '',
                fullName: fullName,
                allCodes: new Set(),
                rating: BASE_RATING,
                tournaments: 0,
                rounds: 0,
                wins: 0,
                losses: 0,
                affWins: 0,
                affLosses: 0,
                negWins: 0,
                negLosses: 0,
                isTop50: false,
                opponents: new Set(),
                opponentSchools: new Set(),
                walkovers: 0,
                tournamentHistory: [],
                tournamentStats: {},
                ratingHistory: [BASE_RATING],
                isUnresolved: false,
                unresolvedAtTournaments: []
            };
        };

        // MAIN COMPETITOR RESOLUTION FUNCTION
        const getCompetitor = (code, tournamentName = null) => {
            // Step 1: Try EXACT match from tournament entries
            let resolved = null;
            if (tournamentName) {
                resolved = resolveCodeForTournament(code, tournamentName);
            }
            
            if (!resolved) {
                // CODE NOT FOUND IN ENTRIES - this is a data issue!
                if (tournamentName) {
                    recordUnresolved(code, tournamentName);
                }
                
                // Create isolated competitor with tournament-specific ID
                const isolatedId = tournamentName 
                    ? `UNRESOLVED::${tournamentName}::${code}`
                    : `UNRESOLVED::${code}`;
                
                if (!state.competitors[isolatedId]) {
                    state.competitors[isolatedId] = createNewCompetitor(
                        isolatedId, 
                        extractSchoolFromCode(code), 
                        null
                    );
                    state.competitors[isolatedId].isUnresolved = true;
                    state.competitors[isolatedId].unresolvedAtTournaments = [tournamentName || 'unknown'];
                    state.competitors[isolatedId].allCodes.add(code);
                }
                
                return state.competitors[isolatedId];
            }
            
            // Step 2: FOUND! Use normalized NAME as the canonical ID
            const normalizedName = normalizeName(resolved.name);
            const canonicalId = normalizedName;
            
            // Step 3: Check if this is a NEW competitor or MERGE
            const isNew = !state.competitors[canonicalId];
            const existingCodes = isNew ? new Set() : new Set(state.competitors[canonicalId].allCodes);
            
            // Step 4: Get or create competitor using name as ID
            if (isNew) {
                state.competitors[canonicalId] = createNewCompetitor(
                    canonicalId,
                    resolved.school,
                    resolved.name
                );
                recordNewCompetitor(resolved.name, code, tournamentName);
            }
            
            const comp = state.competitors[canonicalId];
            
            // Step 5: Check if this code is new for this competitor (a merge)
            const codeIsNew = !comp.allCodes.has(code) && !comp.allCodes.has(resolved.originalCode);
            
            if (codeIsNew && !isNew) {
                // This is a MERGE - an existing competitor is getting a new code
                recordMerge(resolved.name, code, tournamentName, existingCodes);
            }
            
            // Step 6: Update competitor info
            comp.allCodes.add(code);
            comp.allCodes.add(resolved.originalCode);
            
            if (!comp.school && resolved.school) {
                comp.school = resolved.school;
            }
            
            return comp;
        };

        // ============================================
        // ROUND PROCESSING
        // ============================================
        const processRound = (competitorId, opponentId, won, speaks, tournamentInfo, side, roundName, isWalkover = false) => {
            const tournamentName = tournamentInfo.name;
            const comp = getCompetitor(competitorId, tournamentName);
            const opp = getCompetitor(opponentId, tournamentName);
            
            comp.opponents.add(opp.id);
            comp.opponentSchools.add(opp.school);
            
            // Record matchup history
            if (side === 'aff' && !isWalkover) {
                const matchupKey = [comp.id, opp.id].sort().join('::');
                if (!state.matchupHistory[matchupKey]) {
                    state.matchupHistory[matchupKey] = [];
                }
                state.matchupHistory[matchupKey].push({
                    tournament: tournamentName,
                    round: roundName || 'Unknown',
                    affId: comp.id,
                    negId: opp.id,
                    affName: comp.fullName || comp.id,
                    negName: opp.fullName || opp.id,
                    winnerId: won ? comp.id : opp.id,
                    winnerSide: won ? 'aff' : 'neg'
                });
            }
            
            if (isWalkover) { comp.walkovers += 1; return; }

            const expected = expectedScore(comp.rating, opp.rating);
            const actual = won ? 1 : 0;
            const k = getKFactor(comp.tournaments, comp.isTop50);
            const bidMultiplier = BID_MULTIPLIERS[tournamentInfo.bidLevel] || 1.0;
            const speakerMod = getSpeakerModifier(speaks, won);
            
            let ratingChange = k * bidMultiplier * speakerMod * (actual - expected);
            
            if (state.settings.regionalDiversityPenalty && comp.rounds >= 10) {
                const opponentRatings = Array.from(comp.opponents).map(oppId => 
                    state.competitors[oppId] ? state.competitors[oppId].rating : BASE_RATING
                );
                const avgOppRating = opponentRatings.reduce((sum, r) => sum + r, 0) / opponentRatings.length;
                const ratingGap = comp.rating - avgOppRating;
                
                const diversityRatio = comp.opponentSchools.size / comp.opponents.size;
                if (diversityRatio < 0.5) ratingChange *= 1 - (0.5 - diversityRatio);
                if (ratingGap > 200) ratingChange *= Math.max(0.5, 1 - ((ratingGap - 200) / 1000));
                
                if (won) {
                    if (avgOppRating >= 1600) ratingChange *= Math.min(1.3, 1 + ((avgOppRating - 1600) / 1000));
                    if (ratingGap < -50) ratingChange *= Math.min(1.2, 1 + (Math.abs(ratingGap) / 2000));
                }
                
                if (comp.rounds >= 20) {
                    const winRate = comp.wins / comp.rounds;
                    if (winRate >= 0.70 && avgOppRating >= 1550) {
                        const qualityFactor = (avgOppRating - 1500) / 500;
                        const winRateFactor = (winRate - 0.70) * 2;
                        ratingChange *= 1 + Math.min(0.25, qualityFactor * 0.15 + winRateFactor * 0.15);
                    }
                }
            }

            comp.rating += ratingChange;
            comp.ratingHistory.push(comp.rating);
            comp.rounds += 1;
            if (won) {
                comp.wins += 1;
                if (side === 'aff') comp.affWins++;
                else if (side === 'neg') comp.negWins++;
            } else {
                comp.losses += 1;
                if (side === 'aff') comp.affLosses++;
                else if (side === 'neg') comp.negLosses++;
            }
        };

        // ============================================
        // CSV PARSING
        // ============================================
        const parseCSV = (text) => {
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            if (lines.length === 0) return [];
            
            const parseLine = (line) => {
                const result = [];
                let current = '';
                let inQuote = false;
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') inQuote = !inQuote;
                    else if (char === ',' && !inQuote) { result.push(current.trim()); current = ''; }
                    else current += char;
                }
                let val = current.trim();
                if (val.startsWith('"') && val.endsWith('"')) val = val.slice(1, -1).trim();
                result.push(val);
                return result;
            };

            const headers = parseLine(lines[0]).map(h => h.toLowerCase().trim());
            const rows = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseLine(lines[i]);
                if (values.length < headers.length) continue;
                const row = {};
                headers.forEach((header, index) => { row[header] = values[index] || ''; });
                rows.push(row);
            }
            return rows;
        };

        const getRoundNumber = (filename) => {
            const match = filename.match(/(\d+)/);
            return match ? parseInt(match[0]) : 0;
        };

        const determineBidLevel = (name) => {
            const lower = name.toLowerCase();
            if (lower.includes('octas') || lower.includes('octofinals')) return 'octas';
            if (lower.includes('quarters') || lower.includes('quarterfinals')) return 'quarters';
            if (lower.includes('semis') || lower.includes('semifinals')) return 'semis';
            if (lower.includes('finals')) return 'finals';
            return null;
        };

        // Parse entries file - store EXACT mappings only
        const parseEntriesFile = (text, tournamentName) => {
            const rows = parseCSV(text);
            const mappings = [];
            
            if (!state.tournamentEntriesMap[tournamentName]) {
                state.tournamentEntriesMap[tournamentName] = {};
            }
            
            for (const row of rows) {
                let code = (row.code || '').toString().trim();
                let name = (row.entry || row.name || '').toString().trim();
                let school = (row.institution || row.school || '').toString().trim();
                
                if (name && code) {
                    const normalizedCode = normalizeCode(code);
                    
                    state.tournamentEntriesMap[tournamentName][normalizedCode] = {
                        name: name,
                        originalCode: code,
                        school: school
                    };
                    
                    mappings.push({ code, name, school });
                }
            }
            
            log(`  Loaded ${mappings.length} entries for ${tournamentName}`);
            debugLog('info', `Loaded ${mappings.length} entries for ${tournamentName}`);
            return mappings;
        };

        // ============================================
        // FILE LOADING
        // ============================================
        const fetchFile = async (path) => {
            if (fileCache.has(path)) return fileCache.get(path);
            try {
                const response = await fetch(getDirectUrl(path));
                if (response.ok) {
                    const text = await response.text();
                    fileCache.set(path, text);
                    return text;
                }
                return null;
            } catch (e) {
                return null;
            }
        };

        const loadManifest = async () => {
            const text = await fetchFile('manifest.json');
            if (text) {
                try {
                    return JSON.parse(text);
                } catch (e) {
                    console.error('Failed to parse manifest:', e);
                }
            }
            return null;
        };

        const discoverSeasons = async () => {
            const manifest = await loadManifest();
            if (manifest && manifest.seasons) {
                return manifest.seasons.sort().reverse();
            }
            
            const currentYear = new Date().getFullYear();
            const possibleSeasons = [];
            for (let year = currentYear + 1; year >= 2020; year--) {
                possibleSeasons.push(`${year}-${year + 1}`);
            }
            
            const checks = await Promise.all(
                possibleSeasons.map(async (season) => {
                    const response = await fetch(getDirectUrl(`${season}/LD/`), { method: 'HEAD' }).catch(() => null);
                    return response && response.ok ? season : null;
                })
            );
            
            return checks.filter(Boolean);
        };

        const discoverTournaments = async (season, manifest) => {
            if (manifest && manifest.data && manifest.data[season] && manifest.data[season].tournaments.length > 0) {
                return manifest.data[season].tournaments;
            }
            
            const tournamentsListText = await fetchFile(`${season}/LD/tournaments.txt`);
            if (tournamentsListText) {
                const tournamentNames = tournamentsListText.split('\n').map(t => t.trim()).filter(Boolean);
                return await Promise.all(tournamentNames.map(async (name) => {
                    return await discoverTournamentStructure(season, name);
                }));
            }
            
            try {
                const response = await fetch(getDirectUrl(`${season}/LD/`));
                if (response.ok) {
                    const html = await response.text();
                    const tournamentNames = extractLinksFromHTML(html);
                    if (tournamentNames.length > 0) {
                        const tournaments = await Promise.all(
                            tournamentNames.map(name => discoverTournamentStructure(season, name))
                        );
                        return tournaments.filter(t => t.prelims.length > 0 || t.elims.length > 0);
                    }
                }
            } catch (e) {}
            
            return [];
        };

        const extractLinksFromHTML = (html) => {
            const links = [];
            const regex = /href="([^"]+)\/"/g;
            let match;
            while ((match = regex.exec(html)) !== null) {
                const name = match[1];
                if (name && !name.startsWith('.') && !name.startsWith('http') && name !== '..') {
                    links.push(decodeURIComponent(name));
                }
            }
            return links;
        };

        const discoverTournamentStructure = async (season, tournamentName) => {
            const basePath = `${season}/LD/${tournamentName}`;
            const tournament = {
                name: tournamentName,
                path: basePath,
                entries: null,
                prelims: [],
                elims: []
            };

            const entriesFile = await fetchFile(`${basePath}/entries.csv`);
            if (entriesFile) {
                tournament.entries = 'entries.csv';
                tournament.entriesContent = entriesFile;
            }

            try {
                const prelimsHtml = await fetch(getDirectUrl(`${basePath}/Prelims/`)).then(r => r.ok ? r.text() : '');
                tournament.prelims = extractCSVLinksFromHTML(prelimsHtml);
            } catch (e) {}

            try {
                const elimsHtml = await fetch(getDirectUrl(`${basePath}/Elims/`)).then(r => r.ok ? r.text() : '');
                tournament.elims = extractCSVLinksFromHTML(elimsHtml);
            } catch (e) {}

            return tournament;
        };

        const extractCSVLinksFromHTML = (html) => {
            const links = [];
            const regex = /href="([^"]+\.csv)"/gi;
            let match;
            while ((match = regex.exec(html)) !== null) {
                links.push(decodeURIComponent(match[1]));
            }
            return links;
        };

        const populateSeasonDropdown = async () => {
            const seasons = await discoverSeasons();
            if (seasons.length === 0) {
                el.emptyState.querySelector('p').textContent = 'No seasons found. Check repository structure.';
                return;
            }
            
            el.seasonSelect.innerHTML = seasons.map(season => 
                `<option value="${season}" class="bg-[#0a0a0f]">${season}</option>`
            ).join('');
            
            loadSeasonData(seasons[0]);
        };

        // ============================================
        // MAIN DATA LOADING
        // ============================================
        const loadSeasonData = async (season) => {
            state.processing = true;
            state.competitors = {};
            state.tournaments = [];
            state.tournamentEntriesMap = {};
            state.matchupHistory = {};
            state.unresolvedCodes = {};
            state.debugLog = [];
            state.mergeEvents = [];
            state.competitorCreations = {};
            
            el.loadingIndicator.classList.remove('hidden');
            el.emptyState.classList.add('hidden');
            el.exportBtn.disabled = true;
            el.h2hBtn.disabled = true;
            
            const loadingText = document.getElementById('loadingText');
            const updateLoading = (text) => { if (loadingText) loadingText.textContent = text; };
            
            updateLoading('Loading...');
            debugLog('info', `Starting to load season ${season}`);

            try {
                const manifest = await loadManifest();
                
                if (!manifest) {
                    updateLoading('No manifest found. Scanning files (Slow)...');
                    debugLog('warning', 'No manifest found - scanning files');
                    await new Promise(r => setTimeout(r, 1000));
                } else {
                    updateLoading('Loading from manifest...');
                    debugLog('info', 'Manifest loaded successfully');
                }

                const tournaments = await discoverTournaments(season, manifest);
                
                if (tournaments.length === 0) {
                    throw new Error(`No tournaments found for ${season}.`);
                }
                
                updateLoading(`Loading ${tournaments.length} tournaments...`);
                debugLog('info', `Found ${tournaments.length} tournaments`);

                // Build list of ALL files to fetch
                const allFilesToFetch = [];
                
                for (const tournament of tournaments) {
                    if (tournament.entries && !tournament.entriesContent) {
                        allFilesToFetch.push({
                            type: 'entries',
                            tournament: tournament.name,
                            path: `${tournament.path}/${tournament.entries}`
                        });
                    }
                    
                    for (const filename of (tournament.prelims || [])) {
                        allFilesToFetch.push({
                            type: 'prelim',
                            tournament: tournament.name,
                            tournamentData: tournament,
                            filename,
                            path: `${tournament.path}/Prelims/${filename}`
                        });
                    }
                    
                    for (const filename of (tournament.elims || [])) {
                        allFilesToFetch.push({
                            type: 'elim',
                            tournament: tournament.name,
                            tournamentData: tournament,
                            filename,
                            path: `${tournament.path}/Elims/${filename}`
                        });
                    }
                }
                
                // Fetch ALL files in parallel
                const fetchResults = await Promise.all(
                    allFilesToFetch.map(async (file) => {
                        const text = await fetchFile(file.path);
                        return { ...file, text };
                    })
                );
                
                // Get tournament order
                const CORRECT_TOURNAMENT_ORDER = [
                    "LaCosta", "BlueKey", "TOCDigital1", "StMarks", "Heritage Hall",
                    "CollegePrep", "DowlingCatholic", "Emory", "Alta", "Greenhill",
                    "Badgerland", "LonghornClassic", "Peninsula", "HarvardWestlake",
                    "Princeton", "AppleValley", "Meadows", "NSDSO_Online", "Loyola",
                    "Grapevine", "IsidoreNewman", "MidAmerica", "Yale", "Bronx",
                    "Glenbrooks", "Damus", "Blake", "JackHowe", "NanoNagle"
                ];
                
                let tournamentOrder;
                if (manifest && manifest.data && manifest.data[season] && manifest.data[season].tournamentOrder && manifest.data[season].tournamentOrder.length > 0) {
                    tournamentOrder = [...manifest.data[season].tournamentOrder];
                } else {
                    tournamentOrder = [...CORRECT_TOURNAMENT_ORDER];
                }
                
                const orderSet = new Set(tournamentOrder);
                for (const t of tournaments) {
                    if (!orderSet.has(t.name)) {
                        tournamentOrder.push(t.name);
                    }
                }
                
                // Create a map for quick tournament lookup
                const tournamentByName = {};
                for (const t of tournaments) {
                    tournamentByName[t.name] = t;
                }
                
                // Build map of fetched entries
                const entryResultsByTournament = {};
                for (const result of fetchResults) {
                    if (result.type === 'entries' && result.text) {
                        entryResultsByTournament[result.tournament] = result;
                    }
                }
                
                // Process entries in order
                let totalEntries = 0;
                const processedEntries = new Set();
                for (const tName of tournamentOrder) {
                    if (processedEntries.has(tName)) continue;
                    
                    const tournament = tournamentByName[tName];
                    
                    if (tournament && tournament.entriesContent) {
                        const mappings = parseEntriesFile(tournament.entriesContent, tournament.name);
                        totalEntries += mappings.length;
                        processedEntries.add(tName);
                    } else if (entryResultsByTournament[tName]) {
                        const result = entryResultsByTournament[tName];
                        const mappings = parseEntriesFile(result.text, result.tournament);
                        totalEntries += mappings.length;
                        processedEntries.add(tName);
                    }
                }
                
                debugLog('info', `Total entries loaded: ${totalEntries}`);

                // Group round files by tournament
                const fileContents = fetchResults.filter(f => f.type === 'prelim' || f.type === 'elim');
                
                const tournamentFiles = {};
                for (const file of fileContents) {
                    if (!tournamentFiles[file.tournament]) {
                        tournamentFiles[file.tournament] = { prelims: [], elims: [], data: file.tournamentData };
                    }
                    if (file.text) {
                        if (file.type === 'prelim') {
                            tournamentFiles[file.tournament].prelims.push({ filename: file.filename, text: file.text });
                        } else {
                            tournamentFiles[file.tournament].elims.push({ filename: file.filename, text: file.text });
                        }
                    }
                }
                
                // Process tournaments in order
                for (const tName of tournamentOrder) {
                    const tFiles = tournamentFiles[tName];
                    if (!tFiles) continue;
                    
                    debugLog('tournament', `Processing ${tName}`);
                    
                    let bidLevel = determineBidLevel(tName) || 'quarters';
                    
                    const prelims = (tFiles.prelims || []).sort((a, b) => getRoundNumber(a.filename) - getRoundNumber(b.filename));
                    const elims = (tFiles.elims || []).sort((a, b) => getRoundNumber(a.filename) - getRoundNumber(b.filename));

                    const tournamentInfo = { name: tName, bidLevel };
                    const participants = new Set();
                    const elimPlacements = {};
                    
                    for (const { filename, text } of prelims) {
                        const rows = parseCSV(text);
                        
                        for (const row of rows) {
                            const aff = row.aff || '';
                            const neg = row.neg || '';
                            const winner = (row.win || '').toString().toLowerCase();
                            
                            const affSpeaks = parseFloat(row['aff points'] || row.aff_points || row['aff speaks'] || 28);
                            const negSpeaks = parseFloat(row['neg points'] || row.neg_points || row['neg speaks'] || 28);

                            if (!aff || !neg) continue;
                            if (aff.toLowerCase().includes('bye') || neg.toLowerCase().includes('bye')) continue;

                            let affWon = winner === 'aff' || winner === 'a' || winner.includes(aff.toLowerCase());
                            let negWon = winner === 'neg' || winner === 'n' || winner.includes(neg.toLowerCase());
                            
                            if (!affWon && !negWon) continue;

                            const affComp = getCompetitor(aff, tName);
                            const negComp = getCompetitor(neg, tName);
                            
                            participants.add(affComp.id);
                            participants.add(negComp.id);
                            const isWalkover = state.settings.walkoversEnabled && (affComp.school === negComp.school);

                            const roundName = filename.replace('.csv', '').replace(/tabroom-?\d*/i, '').trim() || `Prelim ${getRoundNumber(filename)}`;
                            processRound(aff, neg, affWon, affSpeaks, tournamentInfo, 'aff', roundName, isWalkover);
                            processRound(neg, aff, negWon, negSpeaks, tournamentInfo, 'neg', roundName, isWalkover);

                            const updatePrelimStats = (id, won, isWO) => {
                                const comp = getCompetitor(id, tName);
                                if (!comp.tournamentStats[tName]) comp.tournamentStats[tName] = { pWins: 0, pLosses: 0, maxElim: null };
                                if (!isWO) {
                                    if (won) comp.tournamentStats[tName].pWins++;
                                    else comp.tournamentStats[tName].pLosses++;
                                }
                            };
                            updatePrelimStats(aff, affWon, isWalkover);
                            updatePrelimStats(neg, negWon, isWalkover);
                        }
                    }

                    for (const { filename, text } of elims) {
                        const rows = parseCSV(text);

                        let elimLevel = 'quarters';
                        const lower = filename.toLowerCase();
                        if (lower.includes('oct')) elimLevel = 'octas';
                        else if (lower.includes('semi')) elimLevel = 'semis';
                        else if (lower.includes('final')) elimLevel = 'finals';
                        else {
                            if (rows.length === 1) elimLevel = 'finals';
                            else if (rows.length <= 2) elimLevel = 'semis';
                            else if (rows.length <= 4) elimLevel = 'quarters';
                            else elimLevel = 'octas';
                        }
                        
                        for (const row of rows) {
                            if (row.round) {
                                const r = row.round.toLowerCase();
                                if (r.includes('oct')) elimLevel = 'octas';
                                else if (r.includes('quarter') || r.includes('qtr')) elimLevel = 'quarters';
                                else if (r.includes('semi')) elimLevel = 'semis';
                                else if (r.includes('final')) elimLevel = 'finals';
                            }

                            const aff = row.aff || '';
                            const neg = row.neg || '';
                            const winner = (row.win || '').toString().toLowerCase();
                            
                            const affSpeaks = parseFloat(row['aff points'] || row.aff_points || row['aff speaks'] || 28);
                            const negSpeaks = parseFloat(row['neg points'] || row.neg_points || row['neg speaks'] || 28);

                            if (!aff || !neg) continue;

                            let affWon = winner === 'aff' || winner.includes('aff');
                            let negWon = winner === 'neg' || winner.includes('neg');

                            if (!affWon && !negWon) continue;

                            const affComp = getCompetitor(aff, tName);
                            const negComp = getCompetitor(neg, tName);
                            
                            participants.add(affComp.id);
                            participants.add(negComp.id);
                            const isWalkover = state.settings.walkoversEnabled && (affComp.school === negComp.school);

                            const elimRoundName = elimLevel.charAt(0).toUpperCase() + elimLevel.slice(1);
                            processRound(aff, neg, affWon, affSpeaks, tournamentInfo, 'aff', elimRoundName, isWalkover);
                            processRound(neg, aff, negWon, negSpeaks, tournamentInfo, 'neg', elimRoundName, isWalkover);

                            const updateElimStats = (id, level, isWinner) => {
                                const comp = getCompetitor(id, tName);
                                if (!comp.tournamentStats[tName]) comp.tournamentStats[tName] = { pWins: 0, pLosses: 0, maxElim: null };
                                
                                const val = { 'octas': 1, 'quarters': 2, 'semis': 3, 'finals': 4, 'winner': 5 };
                                const displayMap = { 'octas': 'Octafinals', 'quarters': 'Quarterfinals', 'semis': 'Semifinals', 'finals': 'Finals', 'winner': 'Champion' };
                                
                                const currentMax = comp.tournamentStats[tName].maxElim;
                                const currentVal = currentMax ? val[Object.keys(displayMap).find(k => displayMap[k] === currentMax)] || 0 : 0;
                                
                                let reachedLevel = level;
                                if (isWinner && level === 'finals') reachedLevel = 'winner';
                                else if (isWinner) {
                                    if (level === 'octas') reachedLevel = 'quarters';
                                    else if (level === 'quarters') reachedLevel = 'semis';
                                    else if (level === 'semis') reachedLevel = 'finals';
                                }

                                if (val[reachedLevel] > currentVal) {
                                    comp.tournamentStats[tName].maxElim = displayMap[reachedLevel];
                                }
                            };
                            updateElimStats(aff, elimLevel, affWon);
                            updateElimStats(neg, elimLevel, negWon);
                            
                            const recordPlacement = (id, level) => {
                                const comp = getCompetitor(id, tName);
                                const canonId = comp.id;
                                const levels = { 'octas': 1, 'quarters': 2, 'semis': 3, 'finals': 4, 'winner': 5 };
                                if (!elimPlacements[canonId] || levels[level] > levels[elimPlacements[canonId]]) {
                                    elimPlacements[canonId] = level;
                                }
                            };

                            recordPlacement(aff, elimLevel);
                            recordPlacement(neg, elimLevel);
                            
                            if (elimLevel === 'finals') {
                                recordPlacement(affWon ? aff : neg, 'winner');
                            }
                        }
                    }

                    for (const [id, level] of Object.entries(elimPlacements)) {
                        const bonus = ELIM_BONUSES[level] || 0;
                        if (bonus > 0 && state.competitors[id]) {
                            state.competitors[id].rating += bonus;
                        }
                    }

                    participants.forEach(id => {
                        const comp = state.competitors[id];
                        if (comp) {
                            comp.tournaments++;
                            comp.tournamentHistory.push({ name: tName, rating: Math.round(comp.rating) });
                            if (comp.rating > 1800) comp.isTop50 = true;
                        }
                    });
                    
                    state.tournaments.push({ ...tournamentInfo, participants: participants.size });
                }

                debugLog('info', `Completed loading ${state.tournaments.length} tournaments`);
                debugLog('info', `${Object.keys(state.competitors).length} total competitors`);
                debugLog('info', `${state.mergeEvents.length} merge events`);
                
                const unresolvedTotal = Object.values(state.unresolvedCodes).reduce((sum, set) => sum + set.size, 0);
                if (unresolvedTotal > 0) {
                    debugLog('warning', `${unresolvedTotal} unresolved codes - check Debug Panel`);
                }

                renderStats();
                renderRankings();
                renderDebugContent();
                el.exportBtn.disabled = false;
                el.h2hBtn.disabled = false;

            } catch (err) {
                debugLog('unresolved', `Error: ${err.message}`);
                console.error(err);
                el.emptyState.classList.remove('hidden');
                el.emptyState.querySelector('p').textContent = `Failed to load data: ${err.message}`;
            } finally {
                state.processing = false;
                el.loadingIndicator.classList.add('hidden');
            }
        };

        // ============================================
        // RENDER FUNCTIONS
        // ============================================
        const renderStats = () => {
            const realCompetitors = Object.values(state.competitors).filter(c => !c.isUnresolved);
            el.competitorsStat.textContent = realCompetitors.length;
            el.tournamentsStat.textContent = state.tournaments.length;
            el.roundsStat.textContent = realCompetitors.reduce((s, c) => s + c.rounds, 0);
        };

        const renderRankings = (searchQuery = '') => {
            const allComps = Object.values(state.competitors)
                .filter(comp => !comp.isUnresolved || searchQuery.toLowerCase().includes('unresolved'))
                .sort((a, b) => b.rating - a.rating);
            
            let comps;
            let isSearching = searchQuery.trim().length > 0;
            
            if (isSearching) {
                const query = searchQuery.toLowerCase().trim();
                comps = allComps.filter(comp => {
                    if (comp.fullName && comp.fullName.toLowerCase().includes(query)) return true;
                    if (comp.id.toLowerCase().includes(query)) return true;
                    if (comp.school && comp.school.toLowerCase().includes(query)) return true;
                    if (comp.allCodes) {
                        for (const code of comp.allCodes) {
                            if (code.toLowerCase().includes(query)) return true;
                        }
                    }
                    return false;
                });
                el.rankingsTitle.textContent = `Search Results (${comps.length} found)`;
            } else {
                comps = allComps.slice(0, 50);
                el.rankingsTitle.textContent = 'Top 50 Rankings';
            }
            
            if (comps.length === 0) {
                el.emptyState.classList.remove('hidden');
                el.rankingsContainer.classList.add('hidden');
                return;
            }
            
            el.emptyState.classList.add('hidden');
            el.rankingsContainer.classList.remove('hidden');
            el.rankingsContainer.innerHTML = '';
            
            comps.forEach((comp, index) => {
                const actualRank = allComps.findIndex(c => c.id === comp.id) + 1;
                let displayName = comp.fullName || comp.id;
                
                if (comp.isUnresolved) {
                    displayName = `⚠️ ${displayName.replace('UNRESOLVED::', '')}`;
                }

                const oppRatings = Array.from(comp.opponents).map(o => 
                    state.competitors[o] ? state.competitors[o].rating : BASE_RATING
                );
                const avgOpp = Math.round(oppRatings.reduce((a, b) => a + b, 0) / (oppRatings.length || 1));
                const winRate = comp.rounds > 0 ? ((comp.wins / comp.rounds) * 100).toFixed(1) : 0;
                const ratingGap = Math.round(comp.rating) - avgOpp;
                
                comp.affRounds = comp.affWins + comp.affLosses;
                comp.negRounds = comp.negWins + comp.negLosses;
                const peakRating = Math.round(Math.max(...comp.ratingHistory));
                
                let badgeClass = 'bg-white/10 text-white/60';
                if (comp.isUnresolved) badgeClass = 'bg-red-500/20 text-red-400';
                else if (actualRank === 1) badgeClass = 'bg-yellow-500/20 text-yellow-400';
                else if (actualRank === 2) badgeClass = 'bg-gray-400/20 text-gray-300';
                else if (actualRank === 3) badgeClass = 'bg-amber-600/20 text-amber-500';

                const row = document.createElement('div');
                row.className = 'competitor-row';
                row.innerHTML = `
                    <div class="flex items-center gap-4 px-6 py-4 cursor-pointer select-none" onclick="toggleDropdown(${index})">
                        <div class="rank-badge ${badgeClass}">${comp.isUnresolved ? '?' : actualRank}</div>
                        <div class="flex-1 min-w-0">
                            <div class="font-medium text-white truncate">${displayName}</div>
                            <div class="text-xs text-white/30 truncate">${comp.school || 'Unknown School'} ${comp.isUnresolved ? `<span class="text-red-400">(Data Issue)</span>` : ''}</div>
                        </div>
                        <div class="text-right">
                            <div class="text-lg font-semibold text-white tabular-nums">${Math.round(comp.rating)}</div>
                            <div class="text-xs text-white/30">${comp.wins}-${comp.losses}</div>
                        </div>
                        <svg class="chevron w-4 h-4 text-white/20" id="chevron-${index}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                    </div>
                    <div class="dropdown-content px-6 pb-4" id="dropdown-${index}">
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 pt-2 border-t border-white/5">
                            <div class="bg-white/5 rounded-lg p-3">
                                <div class="text-[10px] text-white/30 uppercase tracking-wider">Win Rate</div>
                                <div class="text-sm font-medium text-white mt-1">${winRate}%</div>
                            </div>
                            <div class="bg-white/5 rounded-lg p-3">
                                <div class="text-[10px] text-white/30 uppercase tracking-wider">Peak Rating</div>
                                <div class="text-sm font-medium text-white mt-1">${peakRating}</div>
                            </div>
                            <div class="bg-white/5 rounded-lg p-3">
                                <div class="text-[10px] text-white/30 uppercase tracking-wider">Avg Opponent</div>
                                <div class="text-sm font-medium ${ratingGap > 150 ? 'text-orange-400' : ratingGap < -100 ? 'text-green-400' : 'text-white'} mt-1">${avgOpp}</div>
                            </div>
                            <div class="bg-white/5 rounded-lg p-3">
                                <div class="text-[10px] text-white/30 uppercase tracking-wider">Tournaments</div>
                                <div class="text-sm font-medium text-white mt-1">${comp.tournaments}</div>
                            </div>
                            <div class="bg-white/5 rounded-lg p-3">
                                <div class="text-[10px] text-white/30 uppercase tracking-wider">Total Rounds</div>
                                <div class="text-sm font-medium text-white mt-1">${comp.rounds}</div>
                            </div>
                            <div class="bg-white/5 rounded-lg p-3">
                                <div class="text-[10px] text-white/30 uppercase tracking-wider">Schools Faced</div>
                                <div class="text-sm font-medium text-white mt-1">${comp.opponentSchools.size}</div>
                            </div>
                            <div class="bg-white/5 rounded-lg p-3">
                                <div class="text-[10px] text-white/30 uppercase tracking-wider">Aff Win Rate</div>
                                <div class="text-sm font-medium text-white mt-1">${comp.affRounds > 0 ? Math.round((comp.affWins/comp.affRounds)*100) : 0}% <span class="text-xs text-white/30">(${comp.affWins}-${comp.affLosses})</span></div>
                            </div>
                            <div class="bg-white/5 rounded-lg p-3">
                                <div class="text-[10px] text-white/30 uppercase tracking-wider">Neg Win Rate</div>
                                <div class="text-sm font-medium text-white mt-1">${comp.negRounds > 0 ? Math.round((comp.negWins/comp.negLosses)*100) : 0}% <span class="text-xs text-white/30">(${comp.negWins}-${comp.negLosses})</span></div>
                            </div>
                        </div>
                        ${comp.isUnresolved ? `
                        <div class="mt-3 bg-red-500/10 border border-red-500/30 rounded-lg p-3">
                            <div class="text-xs text-red-400 font-medium mb-1">⚠️ Data Resolution Issue</div>
                            <div class="text-xs text-white/50">This code was not found in entries.csv at: ${comp.unresolvedAtTournaments.join(', ')}</div>
                        </div>
                        ` : ''}
                        ${Object.keys(comp.tournamentStats || {}).length > 0 ? `
                        <div class="mt-4">
                            <div class="text-[10px] text-white/30 uppercase tracking-wider mb-2">Tournament Performance</div>
                            <div class="grid grid-cols-1 gap-1">
                                ${Object.entries(comp.tournamentStats).map(([tName, stats]) => `
                                    <div class="flex items-center justify-between bg-white/5 rounded px-3 py-2 text-xs">
                                        <div class="font-medium text-white/70">${tName}</div>
                                        <div class="flex items-center gap-3">
                                            <div class="text-white/40"><span class="text-white">${stats.pWins}-${stats.pLosses}</span></div>
                                            ${stats.maxElim ? 
                                                `<div class="bg-blue-500/20 text-blue-300 px-2 py-0.5 rounded text-[10px] uppercase tracking-wide font-semibold">${stats.maxElim}</div>` 
                                                : '<div class="text-white/20 text-[10px]">PRELIMS</div>'}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                        ${comp.allCodes && comp.allCodes.size > 0 ? `
                        <div class="mt-3 text-xs text-white/30">
                            <span class="text-white/50">Codes used:</span> ${Array.from(comp.allCodes).join(', ')}
                        </div>
                        ` : ''}
                    </div>
                `;
                el.rankingsContainer.appendChild(row);
            });
        };

        window.toggleDropdown = (index) => {
            const dropdown = document.getElementById(`dropdown-${index}`);
            const chevron = document.getElementById(`chevron-${index}`);
            dropdown.classList.toggle('open');
            chevron.classList.toggle('open');
        };

        // ============================================
        // DEBUG PANEL FUNCTIONS
        // ============================================
        const initDebugPanel = () => {
            const toggle = document.getElementById('debugToggle');
            const content = document.getElementById('debugContent');
            const chevron = document.getElementById('debugChevron');
            const tabs = document.querySelectorAll('.debug-tab');
            const searchInput = document.getElementById('debugSearch');
            
            toggle.addEventListener('click', () => {
                content.classList.toggle('open');
                chevron.style.transform = content.classList.contains('open') ? 'rotate(180deg)' : '';
                if (content.classList.contains('open')) {
                    renderDebugContent();
                }
            });
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    document.querySelectorAll('.debug-tab-content').forEach(c => c.classList.add('hidden'));
                    const tabId = `debugTab${tab.dataset.tab.charAt(0).toUpperCase() + tab.dataset.tab.slice(1)}`;
                    document.getElementById(tabId).classList.remove('hidden');
                    renderDebugContent(tab.dataset.tab);
                });
            });
            
            let searchTimeout;
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    const activeTab = document.querySelector('.debug-tab.active').dataset.tab;
                    renderDebugContent(activeTab, searchInput.value);
                }, 150);
            });
        };

        const renderDebugContent = (tab = 'merges', searchQuery = '') => {
            const query = searchQuery.toLowerCase().trim();
            
            document.getElementById('debugMergeCount').textContent = `${state.mergeEvents.length} merges`;
            
            const unresolvedTotal = Object.values(state.unresolvedCodes).reduce((sum, set) => sum + set.size, 0);
            const unresolvedBadge = document.getElementById('debugUnresolvedCount');
            if (unresolvedTotal > 0) {
                unresolvedBadge.textContent = `${unresolvedTotal} unresolved`;
                unresolvedBadge.classList.remove('hidden');
            } else {
                unresolvedBadge.classList.add('hidden');
            }
            
            switch (tab) {
                case 'merges': renderMergesTab(query); break;
                case 'unresolved': renderUnresolvedTab(query); break;
                case 'competitors': renderCompetitorsTab(query); break;
                case 'timeline': renderTimelineTab(query); break;
            }
        };

        const renderMergesTab = (query = '') => {
            const container = document.getElementById('debugMergesList');
            const emptyState = document.getElementById('debugMergesEmpty');
            
            let merges = [...state.mergeEvents].reverse();
            
            if (query) {
                merges = merges.filter(m => 
                    m.canonicalName.toLowerCase().includes(query) ||
                    m.newCode.toLowerCase().includes(query) ||
                    m.tournament.toLowerCase().includes(query) ||
                    [...m.existingCodes].some(c => c.toLowerCase().includes(query))
                );
            }
            
            if (merges.length === 0) {
                container.innerHTML = '';
                emptyState.classList.remove('hidden');
                return;
            }
            
            emptyState.classList.add('hidden');
            
            const grouped = {};
            merges.forEach(m => {
                if (!grouped[m.canonicalName]) grouped[m.canonicalName] = [];
                grouped[m.canonicalName].push(m);
            });
            
            container.innerHTML = Object.entries(grouped).map(([name, events]) => {
                const comp = state.competitors[normalizeName(name)];
                const allCodes = comp ? [...comp.allCodes] : [];
                const roundCount = comp ? comp.rounds : 0;
                const hasWarning = events.length >= 3;
                
                return `
                    <div class="merge-card ${hasWarning ? 'warning' : ''}">
                        <div class="flex items-start justify-between mb-2">
                            <div>
                                <div class="font-medium text-white">${name}</div>
                                <div class="text-xs text-white/40">${roundCount} total rounds • ${allCodes.length} codes</div>
                            </div>
                            ${hasWarning ? `
                                <div class="bg-yellow-500/20 text-yellow-400 text-xs px-2 py-1 rounded flex items-center gap-1">
                                    <svg class="w-3 h-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                                    Many merges
                                </div>
                            ` : ''}
                        </div>
                        <div class="mb-2">
                            <div class="text-[10px] text-white/30 uppercase tracking-wider mb-1">All Codes</div>
                            <div class="flex flex-wrap gap-1">
                                ${allCodes.map(code => `<span class="code-tag">${code}</span>`).join('')}
                            </div>
                        </div>
                        <div class="border-t border-white/5 pt-2 mt-2">
                            <div class="text-[10px] text-white/30 uppercase tracking-wider mb-1">Merge History</div>
                            <div class="space-y-1">
                                ${events.map(e => `
                                    <div class="flex items-center gap-2 text-xs flex-wrap">
                                        <span class="text-white/30">@</span>
                                        <span class="text-purple-400">${e.tournament}</span>
                                        <span class="text-white/20">→</span>
                                        <span class="code-tag new">${e.newCode}</span>
                                        <span class="text-white/30 text-[10px]">merged with</span>
                                        ${[...e.existingCodes].slice(0, 3).map(c => `<span class="code-tag existing">${c}</span>`).join('')}
                                        ${e.existingCodes.length > 3 ? `<span class="text-white/30">+${e.existingCodes.length - 3}</span>` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        };

        const renderUnresolvedTab = (query = '') => {
            const container = document.getElementById('debugUnresolvedList');
            const emptyState = document.getElementById('debugUnresolvedEmpty');
            
            const tournaments = Object.entries(state.unresolvedCodes)
                .filter(([t, codes]) => codes.size > 0)
                .filter(([t, codes]) => {
                    if (!query) return true;
                    if (t.toLowerCase().includes(query)) return true;
                    return [...codes].some(c => c.toLowerCase().includes(query));
                });
            
            if (tournaments.length === 0) {
                container.innerHTML = '';
                emptyState.classList.remove('hidden');
                return;
            }
            
            emptyState.classList.add('hidden');
            
            container.innerHTML = tournaments.map(([tournament, codes]) => {
                const codeArray = [...codes];
                return `
                    <div class="bg-red-500/5 border border-red-500/20 rounded-lg p-4">
                        <div class="flex items-center gap-2 mb-3">
                            <svg class="w-4 h-4 text-red-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
                            <span class="font-medium text-red-400">${tournament}</span>
                            <span class="text-xs text-red-400/60">(${codeArray.length} unresolved)</span>
                        </div>
                        <div class="space-y-2">
                            ${codeArray.map(code => `
                                <div class="flex items-center justify-between bg-white/5 rounded px-3 py-2">
                                    <code class="text-sm text-white/80">${code}</code>
                                    <button class="text-xs text-blue-400 hover:text-blue-300 transition-colors" onclick="searchEntriesFor('${tournament}', '${code.replace(/'/g, "\\'")}')">
                                        Check entries.csv →
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                        <div class="mt-3 text-xs text-white/30">
                            <strong>Fix:</strong> Check the entries.csv file for this tournament
                        </div>
                    </div>
                `;
            }).join('');
        };

        const renderCompetitorsTab = (query = '') => {
            const container = document.getElementById('debugCompetitorsList');
            
            let competitors = Object.values(state.competitors)
                .filter(c => !c.isUnresolved)
                .sort((a, b) => b.rounds - a.rounds);
            
            if (query) {
                competitors = competitors.filter(c => 
                    (c.fullName && c.fullName.toLowerCase().includes(query)) ||
                    c.id.toLowerCase().includes(query) ||
                    (c.school && c.school.toLowerCase().includes(query)) ||
                    [...c.allCodes].some(code => code.toLowerCase().includes(query))
                );
            }
            
            const limited = competitors.slice(0, 100);
            const hasMore = competitors.length > 100;
            
            container.innerHTML = `
                <div class="text-xs text-white/30 mb-3">
                    Showing ${limited.length}${hasMore ? ` of ${competitors.length}` : ''} competitors (sorted by rounds)
                </div>
                <div class="space-y-1">
                    ${limited.map(comp => {
                        const codeCount = comp.allCodes.size;
                        const isSuspicious = codeCount >= 4 || comp.rounds >= 30;
                        return `
                            <div class="flex items-center gap-3 bg-white/5 hover:bg-white/10 rounded px-3 py-2 transition-colors ${isSuspicious ? 'border border-yellow-500/30' : ''}">
                                <div class="flex-1 min-w-0">
                                    <div class="font-medium text-white text-sm truncate">${comp.fullName || comp.id}</div>
                                    <div class="text-xs text-white/30 truncate">${comp.school || 'Unknown'}</div>
                                </div>
                                <div class="text-xs text-white/40">${comp.rounds} rounds</div>
                                <div class="text-xs ${codeCount >= 4 ? 'text-yellow-400' : 'text-white/40'}">${codeCount} codes</div>
                                <button class="text-xs text-blue-400 hover:text-blue-300 transition-colors whitespace-nowrap" onclick="showCompetitorDetail('${comp.id.replace(/'/g, "\\'")}')">Details</button>
                            </div>
                        `;
                    }).join('')}
                </div>
                ${hasMore ? `<div class="text-center text-white/30 text-xs mt-4">Use search to filter results</div>` : ''}
            `;
        };

        const renderTimelineTab = (query = '') => {
            const container = document.getElementById('debugTimelineList');
            const emptyState = document.getElementById('debugTimelineEmpty');
            
            let entries = [...state.debugLog];
            
            if (query) {
                entries = entries.filter(e => 
                    e.message.toLowerCase().includes(query) ||
                    e.type.toLowerCase().includes(query) ||
                    (e.data.tournament && e.data.tournament.toLowerCase().includes(query))
                );
            }
            
            if (entries.length === 0) {
                container.innerHTML = '';
                emptyState.classList.remove('hidden');
                return;
            }
            
            emptyState.classList.add('hidden');
            
            container.innerHTML = entries.map(e => {
                const colors = {
                    'new': 'text-green-400',
                    'merge': 'text-blue-400',
                    'unresolved': 'text-red-400',
                    'tournament': 'text-purple-400',
                    'info': 'text-white/40',
                    'warning': 'text-yellow-400'
                };
                return `
                    <div class="timeline-entry ${e.type}">
                        <span class="${colors[e.type] || 'text-white/60'}">[${e.type.toUpperCase()}]</span>
                        <span class="text-white/80 ml-2">${e.message}</span>
                        ${e.data.tournament ? `<span class="text-purple-400/60 ml-2">@ ${e.data.tournament}</span>` : ''}
                    </div>
                `;
            }).join('');
        };

        window.showCompetitorDetail = (id) => {
            const comp = state.competitors[id];
            if (!comp) { alert('Competitor not found'); return; }
            
            const codes = [...comp.allCodes].join('\n  - ');
            const tournaments = Object.keys(comp.tournamentStats || {}).join('\n  - ');
            
            alert(`
COMPETITOR DETAIL
=================
Name: ${comp.fullName || 'Unknown'}
ID: ${comp.id}
School: ${comp.school || 'Unknown'}

STATS
-----
Rating: ${Math.round(comp.rating)}
Record: ${comp.wins}-${comp.losses}
Rounds: ${comp.rounds}
Tournaments: ${comp.tournaments}

CODES USED
----------
  - ${codes}

TOURNAMENTS
-----------
  - ${tournaments || 'None recorded'}
            `.trim());
        };

        window.searchEntriesFor = (tournament, code) => {
            const entries = state.tournamentEntriesMap[tournament];
            if (!entries) { alert(`No entries loaded for ${tournament}`); return; }
            
            console.log(`\n=== Searching ${tournament} entries for "${code}" ===`);
            
            const school = extractSchoolFromCode(code);
            let found = false;
            
            Object.entries(entries).forEach(([key, entry]) => {
                if (key.includes(school.toLowerCase())) {
                    console.log(`  "${key}" → "${entry.name}" (${entry.originalCode})`);
                    found = true;
                }
            });
            
            if (!found) console.log(`  No entries found for school "${school}"`);
            alert(`Check console for entries from ${tournament} matching "${school}"`);
        };

        // ============================================
        // EXPORT
        // ============================================
        const exportRankings = () => {
            const comps = Object.values(state.competitors)
                .filter(c => !c.isUnresolved)
                .sort((a, b) => b.rating - a.rating);
            
            const csvContent = [
                'Rank,Competitor,FullName,School,AllCodes,Rating,Wins,Losses,Tournaments,Rounds,AvgOppRating',
                ...comps.map((c, i) => {
                    const oppRatings = Array.from(c.opponents).map(o => state.competitors[o]?.rating || BASE_RATING);
                    const avgOpp = Math.round(oppRatings.reduce((a, b) => a + b, 0) / (oppRatings.length || 1));
                    const allCodes = c.allCodes ? Array.from(c.allCodes).join('; ') : c.id;
                    const fullName = c.fullName || '';
                    return `${i + 1},"${c.id}","${fullName}","${c.school}","${allCodes}",${Math.round(c.rating)},${c.wins},${c.losses},${c.tournaments},${c.rounds},${avgOpp}`;
                })
            ].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ld_rankings_${el.seasonSelect.value}.csv`;
            a.click();
        };

        // ============================================
        // HEAD TO HEAD (simplified)
        // ============================================
        const openH2HModal = () => {
            el.h2hModal.classList.remove('hidden');
            el.h2hModal.classList.add('flex');
            state.h2hSelection = { aff: null, neg: null };
        };
        
        const closeH2HModal = () => {
            el.h2hModal.classList.add('hidden');
            el.h2hModal.classList.remove('flex');
        };

        const searchCompetitors = (query) => {
            if (!query || query.length < 2) return [];
            const q = query.toLowerCase();
            return Object.values(state.competitors)
                .filter(c => !c.isUnresolved)
                .filter(comp => {
                    if (comp.fullName && comp.fullName.toLowerCase().includes(q)) return true;
                    if (comp.id.toLowerCase().includes(q)) return true;
                    return false;
                })
                .sort((a, b) => b.rating - a.rating)
                .slice(0, 10);
        };

        const renderH2HDropdown = (dropdown, results, side) => {
            if (results.length === 0) { dropdown.classList.add('hidden'); return; }
            dropdown.innerHTML = results.map(comp => {
                const fullName = comp.fullName || comp.id;
                return `<div class="px-3 py-2 hover:bg-white/10 cursor-pointer transition-colors" data-id="${comp.id}" data-side="${side}">
                    <div class="font-medium text-white text-sm">${fullName}</div>
                    <div class="text-xs text-white/40">${Math.round(comp.rating)}</div>
                </div>`;
            }).join('');
            dropdown.classList.remove('hidden');
            dropdown.querySelectorAll('[data-id]').forEach(item => {
                item.addEventListener('click', () => selectH2HCompetitor(item.dataset.id, item.dataset.side));
            });
        };

        const selectH2HCompetitor = (compId, side) => {
            const comp = state.competitors[compId];
            if (!comp) return;
            const fullName = comp.fullName || comp.id;
            state.h2hSelection[side] = comp;
            
            if (side === 'aff') {
                el.h2hAffSearch.value = fullName;
                el.h2hAffDropdown.classList.add('hidden');
                el.h2hAffSelected.classList.remove('hidden');
                el.h2hAffName.textContent = fullName;
                el.h2hAffCode.textContent = comp.id;
                el.h2hAffRating.textContent = Math.round(comp.rating);
                el.h2hAffRecord.textContent = `${comp.wins}-${comp.losses}`;
            } else {
                el.h2hNegSearch.value = fullName;
                el.h2hNegDropdown.classList.add('hidden');
                el.h2hNegSelected.classList.remove('hidden');
                el.h2hNegName.textContent = fullName;
                el.h2hNegCode.textContent = comp.id;
                el.h2hNegRating.textContent = Math.round(comp.rating);
                el.h2hNegRecord.textContent = `${comp.wins}-${comp.losses}`;
            }
            
            updateH2HPrediction();
        };

        const updateH2HPrediction = () => {
            const aff = state.h2hSelection.aff;
            const neg = state.h2hSelection.neg;
            if (!aff || !neg) return;
            
            const eloProb = expectedScore(aff.rating, neg.rating);
            el.h2hPrediction.classList.remove('hidden');
            el.h2hAffWinProb.textContent = `${Math.round(eloProb * 100)}%`;
            el.h2hNegWinProb.textContent = `${Math.round((1-eloProb) * 100)}%`;
            el.h2hProbBarAff.style.width = `${eloProb * 100}%`;
            el.h2hProbBarNeg.style.width = `${(1-eloProb) * 100}%`;
            
            const favored = eloProb > 0.5 ? (aff.fullName || aff.id) : (neg.fullName || neg.id);
            el.h2hPredictionText.textContent = `${favored} is favored based on ELO ratings`;
            
            el.h2hHistory.classList.remove('hidden');
            const matchupKey = [aff.id, neg.id].sort().join('::');
            const history = state.matchupHistory[matchupKey] || [];
            
            if (history.length === 0) {
                el.h2hHistoryContent.classList.add('hidden');
                el.h2hNoHistory.classList.remove('hidden');
            } else {
                el.h2hNoHistory.classList.add('hidden');
                el.h2hHistoryContent.classList.remove('hidden');
                el.h2hHistoryContent.innerHTML = history.map(m => `
                    <div class="bg-white/5 rounded-lg p-3">
                        <div class="text-sm font-medium text-white">${m.tournament} - ${m.round}</div>
                        <div class="text-xs text-white/40">Winner: ${m.winnerId === aff.id ? (aff.fullName || aff.id) : (neg.fullName || neg.id)} (${m.winnerSide})</div>
                    </div>
                `).join('');
            }
        };

        // ============================================
        // EVENT LISTENERS
        // ============================================
        el.exportBtn.addEventListener('click', exportRankings);
        el.seasonSelect.addEventListener('change', (e) => { if (!state.processing) loadSeasonData(e.target.value); });
        el.h2hBtn.addEventListener('click', openH2HModal);
        el.h2hClose.addEventListener('click', closeH2HModal);
        el.h2hModal.addEventListener('click', (e) => { if (e.target === el.h2hModal) closeH2HModal(); });

        let searchTimeout;
        el.searchInput.addEventListener('input', (e) => {
            const query = e.target.value;
            el.clearSearch.classList.toggle('hidden', query.length === 0);
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (Object.keys(state.competitors).length > 0) renderRankings(query);
            }, 150);
        });
        
        el.clearSearch.addEventListener('click', () => {
            el.searchInput.value = '';
            el.clearSearch.classList.add('hidden');
            if (Object.keys(state.competitors).length > 0) renderRankings();
        });

        let h2hAffTimeout, h2hNegTimeout;
        el.h2hAffSearch.addEventListener('input', (e) => {
            clearTimeout(h2hAffTimeout);
            h2hAffTimeout = setTimeout(() => renderH2HDropdown(el.h2hAffDropdown, searchCompetitors(e.target.value), 'aff'), 150);
        });
        el.h2hNegSearch.addEventListener('input', (e) => {
            clearTimeout(h2hNegTimeout);
            h2hNegTimeout = setTimeout(() => renderH2HDropdown(el.h2hNegDropdown, searchCompetitors(e.target.value), 'neg'), 150);
        });

        document.addEventListener('click', (e) => {
            if (!el.h2hAffSearch.contains(e.target) && !el.h2hAffDropdown.contains(e.target)) el.h2hAffDropdown.classList.add('hidden');
            if (!el.h2hNegSearch.contains(e.target) && !el.h2hNegDropdown.contains(e.target)) el.h2hNegDropdown.classList.add('hidden');
        });

        // ============================================
        // INITIALIZE
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            initDebugPanel();
            populateSeasonDropdown();
        });

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initDebugPanel();
            populateSeasonDropdown();
        }
    </script>
</body>
</html>
